## Защита от удаления системных директорий

Данная инструкция описывает, как защитить систему от случайного удаления критически важных директорий (`/`, `/usr`, `/home` и т.д.) с помощью `safe-rm`. Решение работает **и для обычного `rm`, и для `sudo rm`**, без интерактивных подтверждений.

---

### 1. Установка `safe-rm`

```bash
sudo apt install safe-rm
```

Пакет устанавливает утилиту `safe-rm`, которая проверяет путь перед удалением и отказывается работать с защищёнными директориями.

---

### 2. Проверка стандартного списка защищённых путей

Список директорий, которые запрещено удалять, хранится в файле:

```bash
/etc/safe-rm.conf
```

Посмотреть текущий список:

```bash
cat /etc/safe-rm.conf
```

Обычно там уже есть:

* `/`
* `/usr`
* `/etc`
* `/home`
* `/var`
* `/bin`, `/sbin`, `/lib`, `/proc`, `/sys` и др.

---

### 3. (Опционально) Добавление своих директорий в защиту

Можно защитить пользовательские или рабочие каталоги (указываются **только абсолютные пути**):

```bash
sudo vim /etc/safe-rm.conf
```

Пример:

```text
/home/asus/github
/home/asus/gitlab
/home/asus/Downloads
/var/lib/docker
```

Изменения применяются сразу, перезапуск не требуется.

---

### 4. Ключевой шаг: защита `sudo rm`

По умолчанию `safe-rm` **не подменяет** стандартную команду `rm`. Чтобы защита работала всегда (в том числе через `sudo`), создаётся системная обёртка.

Создаём файл `/usr/local/bin/rm`:

```bash
sudo tee /usr/local/bin/rm >/dev/null <<'EOF'
#!/bin/sh
exec /usr/bin/safe-rm "$@"
EOF

sudo chmod 755 /usr/local/bin/rm
```

Почему это работает:

* `sudo` использует `secure_path`
* `/usr/local/bin` находится **раньше**, чем `/usr/bin`
* при вызове `rm` (даже через `sudo`) используется `safe-rm`

---

### 5. Проверка порядка PATH (обязательно)

Перед использованием системной обёртки необходимо убедиться, что `/usr/local/bin` находится **раньше**, чем `/usr/bin`, как для обычной оболочки, так и для `sudo`.

Проверка для текущего пользователя:

```bash
echo $PATH
command -v rm
```

Проверка для `sudo` (учитывает `secure_path`):

```bash
sudo sh -c 'echo $PATH'
sudo sh -c 'command -v rm'
```

Ожидаемо, что в обоих случаях `rm` будет резолвиться в:

```text
/usr/local/bin/rm
```

Если `/usr/bin/rm` идёт раньше, необходимо проверить настройки `secure_path` в `/etc/sudoers` и порядок директорий в `PATH`.

---

### 6. Сброс кеша команд оболочки

Для zsh или bash:

```bash
hash -r
```

---

### 6. Проверка

Проверяем, какой `rm` используется:

```bash
command -v rm
sudo sh -c 'command -v rm'
```

Ожидаемый результат:

```text
/usr/local/bin/rm
```

Безопасный тест:

```bash
mkdir -p ~/Downloads
sudo rm -rf /home/asus/Downloads
```

Результат:

```text
safe-rm: Skipping /home/asus/Downloads.
```

Каталог останется на месте.

---

### 7. Осознанный обход защиты

Если удаление действительно нужно и выполняется осознанно:

```bash
sudo /bin/rm -rf /path
```

Или:

```bash
sudo /usr/bin/rm -rf /path
```

Это действие невозможно выполнить случайно.

---

### 8. Как откатить изменения

Удалить системную обёртку:

```bash
sudo rm -f /usr/local/bin/rm
hash -r
```

После этого система вернётся к стандартному поведению `rm`.

---

### Итог

* Защищены критические директории системы
* Работает для `rm` и `sudo rm`
* Нет интерактивных подтверждений
* Сохраняется возможность осознанного обхода

Рекомендуется для всех рабочих и серверных систем.
